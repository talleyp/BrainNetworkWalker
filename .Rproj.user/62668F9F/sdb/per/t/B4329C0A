{
    "collab_server" : "",
    "contents" : "library(reshape2)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\nlibrary(modMax)\n\nrm(list=ls())\ngraphics.off()\n\n\npath.lmftp <- paste(getwd(), \"limited_time_mfpt\", sep = \"/\")\npath.data <- paste(path.lmftp,\"data\", \"subject\", sep = \"/\")\npath.code <- paste(path.lmftp, \"code\", sep = \"/\")\npath.result <- paste(path.lmftp, \"results\", sep = \"/\")\npath.csv <- paste(path.result, \"csv\", \"100s_10000r_2\", sep=\"/\")\npath.image <- paste(path.result, \"images\", sep=\"/\")\nsource(paste(path.code, \"run_random_walk.R\", sep = \"/\"))\nsource(paste(path.code, \"cor_matrices.R\", sep = \"/\"))\nsource(paste(path.code, \"heatPlot.R\", sep = \"/\"))\nsource(paste(path.code, \"makesym.R\", sep = \"/\"))\nsource(paste(path.code, \"zscore.R\", sep = \"/\"))\nsource(paste(path.code, \"makedelta.R\", sep = \"/\"))\nsource(paste(path.code, \"test_functions.R\", sep = \"/\"))\nsource(paste(path.code, \"multiple_walkers.R\",sep=\"/\"))\n\nFC <- as.matrix(read.csv(paste(path.data, \"FC.csv\", sep = \"/\"), header=FALSE))\nSCden <- as.matrix(read.csv(paste(path.data, \"SCden.csv\", sep = \"/\"), header=FALSE))\n\nN <- ncol(FC)\nFC <- FC[(1:(N/2)), (1:(N/2))]\nSCden <- SCden[(1:(N/2)), (1:(N/2))]\nN <-ncol(FC)\nPden <- SCden / rowSums(SCden)\n\n\n# Setup run parameters\nnumSteps <- 100\nnumRuns <- 10000\n\n# Create a 3d array where each slice is a number of steps \n# Columns are source, and rows are target\nfracArr_SCden <- array(data=NaN, dim = c(numSteps, N, N))\nmfpt_SCden <- array(data=NaN, dim = c(numSteps, N, N))\nnArr_SCden <- array(data=NaN, dim = c(numSteps, N, N))\n\nrandMat <- matrix(runif(numRuns * numSteps, min = 0, max = 1), nrow= numRuns, ncol = numSteps)\n\n\nfor(start in 1:N){\n    file.csv <- paste(path.csv,paste(paste(\"walker\", start, sep=\"_\"), \"csv\", sep=\".\"), sep = \"/\")\n    ## Returns the fraction arrival, and the limited time mean first passage time\n    mydata <- r_run_random_walk(Pden,start,numSteps,numRuns,randMat,file.csv)\n    ## Splits them into 2 columns respectively\n    ST_fraction_arrived <- mydata$fraction_arrival\n    ST_lt_mfpt <- mydata$lt_mfpt\n    ST_nArr <- mydata$numArr\n    \n    fracArr_SCden[ , start, ] <- ST_fraction_arrived\n    mfpt_SCden[ , start, ] <- ST_lt_mfpt\n    nArr_SCden[ , start, ] <- ST_nArr\n}\nZ_mfpt <- zscore(mfpt_SCden)\nsym_fracArr_SCden <- makesym(fracArr_SCden, numSteps)\nsym_mfpt_SCden <- makesym(mfpt_SCden, numSteps)\nsym_nArr_SCden <- makesym(nArr_SCden, numSteps)\nsym_z <- makesym(Z_mfpt, numSteps)\n\ndelta <- makedelta(mfpt_SCden)\n\n# Gets the correlation between FC and the simulations\ncorMat <- cor_matrices(numSteps, FC, sym_fracArr_SCden, sym_mfpt_SCden, sym_nArr_SCden, sym_z, delta)\n\n# Test functions between fraction arrival and mfpt\ncorFun <- test_functions(numSteps, FC, sym_fracArr_SCden, sym_mfpt_SCden)\n\n# Grab index of maximum correlation to send to heatplot \nmfptDen <- which(abs(corMat$cor_FC_mfpt) == max(abs(corMat$cor_FC_mfpt), na.rm=TRUE), arr.ind = TRUE)\nfracADen <- which(abs(corMat$cor_FC_FA) == max(abs(corMat$cor_FC_FA), na.rm = TRUE), arr.ind = TRUE)\nnDen <- which(abs(corMat$cor_n_scden) == max(abs(corMat$cor_n_scden), na.rm=TRUE), arr.ind = TRUE)\nnDen <- which(abs(corMat$cor_n_scden) == max(abs(corMat$cor_n_scden), na.rm=TRUE), arr.ind = TRUE)\n\nmultCor<- which(abs(corFun$mult) == max(abs(corFun$mult), na.rm=TRUE), arr.ind = TRUE)\n\n\n\nheatStep <- fracADen\nheatPlot(FC, \"FC\", file = paste(path.image, \"FC.png\", sep = \"/\"))\nheatPlot(mfpt_SCden[heatStep, , ], title = \"MFPT using SCDen\", \n         file = paste(path.image, \"mfptDen.png\", sep = \"/\"))\nheatPlot(fracArr_SCden[heatStep, , ], \"FracA using SCDen\",\n         file = paste(path.image, \"fracADen.png\", sep = \"/\"))\nheatPlot(nArr_SCden[heatStep, , ], \"nArr using SCden\",\n         file = paste(path.image, \"nDen.png\", sep = \"/\"))\nheatPlot(Z_mfpt[heatStep, , ], \"Z using SCden\",\n         file = paste(path.image, \"ZDen.png\", sep = \"/\"))\n\n\ntmat <- sym_fracArr_SCden[fracADen, ,]\ntmat <- tmat[upper.tri(tmat)]\ntmat_in <- tmat[!is.infinite(tmat)]\nupFC <- FC[upper.tri(FC)]\nupFC_in <- upFC[!is.infinite(tmat)]\ncor(upFC_in, tmat_in)\n\n## Scatter for the log of fracA at highest correlation\nmat <- sym_fracArr_SCden[fracADen,,]\nupFA = mat[upper.tri(mat)]\nupFA = log(upFA)\nremin <- !is.infinite(upFA)\nl_fa_sub = which(upFA>-3, arr.ind=T)\nfa_l = upFA[l_fa_sub]\nfa_l = fa_l[remin]\nfc_long = FC[upper.tri(FC)]\nfc_l = fc_long[l_fa_sub]\nfc_l = fc_l[remin]\nline = lm(fc_l~fa_l)\ncorfa <- cor(fa_l,fc_l, use='pairwise.complete.obs')\nqplot(fa_l, fc_l) + geom_smooth(method = \"lm\") + labs(x = 'Fraction Arrival', y = 'FC',\n                                                      title = paste(corfa, \"Correlation, with log\"))\nggsave(paste(path.image,\"cor_fa_log.png\", sep = \"/\"))\n#plot(fa_l, y = fc_l, xlab = 'Log of Fraction Arrival', ylab = 'FC')\n#abline(line, col = 'blue')\n\n\n\n## Scatter for fracA of highest correlation\nmat <- sym_fracArr_SCden[fracADen,,]\nupFA = mat[upper.tri(mat)]\n#upFA = log(upFA)\nremin <- !is.infinite(upFA)\nl_fa_sub = which(upFA>.05, arr.ind=T)\nfa_l = upFA[l_fa_sub]\nfa_l = fa_l[remin]\nfc_long = FC[upper.tri(FC)]\nfc_l = fc_long[l_fa_sub]\nfc_l = fc_l[remin]\ncorfa <- cor(fa_l,fc_l, use='pairwise.complete.obs')\nqplot(fa_l, fc_l) + geom_smooth(method = \"lm\") + labs(x = 'Fraction Arrival', y = 'FC',\n                                                      title = paste(corfa, \"Correlation, without log\"))\nggsave(paste(path.image,\"cor_fa_no_log.png\",sep = \"/\"))\n\n\n## Scatter for mult of highest correlation\nmat <- sym_fracArr_SCden[multCor,,] * sym_mfpt_SCden[multCor,,]\nupFA = mat[upper.tri(mat)]\n#upFA = log(upFA)\nremin <- !is.infinite(upFA)\nl_fa_sub = which(upFA>.05, arr.ind=T)\nfa_l = upFA[l_fa_sub]\nfa_l = fa_l[remin]\nfc_long = FC[upper.tri(FC)]\nfc_l = fc_long[l_fa_sub]\nfc_l = fc_l[remin]\ncorfa <- cor(fa_l,fc_l, use='pairwise.complete.obs')\nqplot(fa_l, fc_l) + geom_smooth(method = \"lm\") + labs(x = 'Fraction Arrival * MFPT', y = 'FC',\n                                                      title = paste(corfa, \"Correlation, mfpt*fracArr\"))\nggsave(paste(path.image,\"cor_mult\",sep = \"/\"))\n\n\n## Calculate SPL and Driftness\ngraphSC <- graph.adjacency(SCden, mode='undirected',weighted=T)\nSPLmat <- shortest.paths(a, algorithm = 'dijkstra')\n\ndrift <- spl_drift(SPLmat, sym_mfpt_SCden)\n\n\n# multiple MFPT\nminwalkers = 5\nmaxwalkers = 10\nnSim = 500\nlibrary(gtools)\nlibrary(doParallel)\nlibrary(foreach)\nlibrary(abind)\ncl <- makeCluster(3)\nregisterDoParallel(cl)\n\nFiles <- list.files(path.csv, full.names = T)\nFiles <- Files[mixedorder(Files)]\nN <- length(Files)\n\nmult_walker_mfpt = NULL#array(data=NaN, dim = c(N,N,maxwalkers, numSteps))\n# Read in file name\nacomb <- function(...) abind(..., along=4)\nptm <- proc.time()\nmult_walker_mfpt = foreach(start = 1:N, .combine='acomb', .multicombine=TRUE) %dopar% {\n    source('/run/media/renge/Beta/Documents/Research/limited_time_mfpt/code/calc_mfpt.R')\n    start_mult_walker_mfpt= array(data=NA, dim = c(N,length(minwalkers:maxwalkers), numSteps))\n    print(\"read data next\")\n    data = read.csv(Files[start])\n    data = data[,-1]\n    data[,1] = 0 # Allows Return time to be calculated\n    #nrow(data) is too large\n    # Set number of walkers\n    for(i in minwalkers:maxwalkers){\n        # make vector of walker bin sizes\n        partseq = seq(1,nSim,i)\n        num = length(partseq) \n        mfptholder = array(data=NA, dim = c(num, numSteps, N))\n        # send to calc_mfpt one batch at a time\n        for(j in 1:num){\n            # set to temp array where column is number of walkers, row is target, page is steps\n            mfptholder[j, , ] = calc_mfpt(data[partseq[j]:(partseq[j]+i-1),], N, numSteps)\n            \n        }\n        # take mean of column \n        # set to mult_walker_mfpt[i, , start, ]\n        start_mult_walker_mfpt[, i-minwalkers+1, ] = colMeans(aperm(mfptholder, c(1, 2, 3)), na.rm=T)\n    }\n    return(start_mult_walker_mfpt)\n}\nstopCluster(cl)\nproc.time()-ptm\n\nswitch_order = aperm(mult_walker_mfpt, c(4,1,2,3))\n\nmult_cor = matrix(data=NA, nrow=numSteps, ncol=length(minwalkers:maxwalkers))\nfor(i in 1:(length(minwalkers:maxwalkers))){\n    for(j in 1:numSteps){\n        mult_cor[j,i] = cor(c(FC), c(switch_order[ , , i, j]),use = \"pairwise.complete.obs\")\n    }\n}",
    "created" : 1458997450707.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3893786784",
    "id" : "B4329C0A",
    "lastKnownWriteTime" : 1461666580,
    "last_content_update" : 1461666580669,
    "path" : "/run/media/renge/Beta/Documents/Research/limited_time_mfpt/code/batch_main_hemisphere.R",
    "project_path" : "limited_time_mfpt/code/batch_main_hemisphere.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}